<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sculptable VTT - Multiplayer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #2e2e2e;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #ccc;
            user-select: none;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 50px;
            background-color: #333;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            box-sizing: border-box;
            z-index: 10;
        }

        .brand {
            font-weight: bold;
            color: #fff;
            font-size: 1.1rem;
        }

        .status {
            font-size: 0.9rem;
            color: #FFC107; /* Default to yellow/loading */
        }

        canvas {
            display: block;
            touch-action: none;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            font-size: 0.85rem;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="brand">Sculptable VTT <span style="font-size:0.8em; color:#888;">Multiplayer</span></div>
        <div class="status" id="connection-status">Connecting...</div>
    </div>

    <div id="instructions">
        Left Click: Spawn Token<br>
        Drag: Move Token<br>
        Right Click: Delete Token
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, deleteDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyDpf0a_L_bLkiIgdhR0RsSHmgDjvUvxk_U",
            authDomain: "battletracker-61545.firebaseapp.com",
            projectId: "battletracker-61545",
            storageBucket: "battletracker-61545.firebasestorage.app",
            messagingSenderId: "993343619812",
            appId: "1:993343619812:web:3bbe65fd664fa09256a2f1"
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        // Use a default app ID if not provided by environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'battletracker-default-room';
        
        // This is the shared collection for all users in this app instance
        // Path: artifacts/{appId}/public/data/tokens
        const TOKENS_COLLECTION = collection(db, 'artifacts', appId, 'public', 'data', 'tokens');

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusLabel = document.getElementById('connection-status');

        // State
        let tokens = {}; 
        let dragData = { item: null, offsetX: 0, offsetY: 0 };
        let currentUser = null;
        let lastWriteTime = 0; // For throttling

        // --- Resize Handling ---
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Core Logic ---

        function generateId() {
            return crypto.randomUUID();
        }

        function getRandomColor() {
            const colors = ["#e57373", "#81c784", "#64b5f6", "#fff176", "#ba68c8", "#ff8a65", "#4db6ac"];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // --- Rendering ---
        function draw() {
            // Background
            ctx.fillStyle = "#2e2e2e";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid
            ctx.strokeStyle = "#383838";
            ctx.lineWidth = 1;
            const gridSize = 50;
            ctx.beginPath();
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }
            ctx.stroke();

            // Tokens
            Object.values(tokens).forEach(token => {
                ctx.beginPath();
                ctx.arc(token.x, token.y, 20, 0, Math.PI * 2);
                ctx.fillStyle = token.color || "#ccc";
                ctx.fill();
                ctx.strokeStyle = "white";
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Highlight if dragging
                if (dragData.item === token.id) {
                    ctx.strokeStyle = "#FFFF00";
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            });
        }

        // --- Firebase Integration ---

        // 1. Initialize & Authenticate
        async function initGame() {
            try {
                await signInAnonymously(auth);
                currentUser = auth.currentUser;
                statusLabel.textContent = "Online";
                statusLabel.style.color = "#4CAF50";
                
                // 2. Start Listening for Updates
                startSync();
            } catch (error) {
                console.error("Auth failed:", error);
                statusLabel.textContent = "Offline (Auth Failed)";
                statusLabel.style.color = "#F44336";
            }
        }

        function startSync() {
            onSnapshot(TOKENS_COLLECTION, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    const data = change.doc.data();
                    const tid = change.doc.id;

                    if (change.type === "added" || change.type === "modified") {
                        tokens[tid] = { id: tid, ...data };
                    }
                    if (change.type === "removed") {
                        delete tokens[tid];
                    }
                });
                draw();
            }, (error) => {
                console.error("Sync error:", error);
                statusLabel.textContent = "Sync Error";
                statusLabel.style.color = "#F44336";
            });
        }

        // 3. Send Actions (Writes to Firestore)
        async function createToken(x, y) {
            if (!currentUser) return;
            const newId = generateId();
            const color = getRandomColor();
            
            // Optimistic update (draw immediately before server confirms)
            tokens[newId] = { id: newId, x, y, color };
            draw();

            try {
                await setDoc(doc(TOKENS_COLLECTION, newId), {
                    x: x,
                    y: y,
                    color: color,
                    createdBy: currentUser.uid
                });
            } catch (e) {
                console.error("Error creating token:", e);
            }
        }

        async function updateTokenPosition(id, x, y) {
            if (!currentUser) return;

            // Throttle network writes to every 100ms to save bandwidth
            const now = Date.now();
            if (now - lastWriteTime < 100) return; 
            lastWriteTime = now;

            try {
                // Use merge: true to avoid overwriting other fields if we add them later
                await setDoc(doc(TOKENS_COLLECTION, id), { x, y }, { merge: true });
            } catch (e) {
                console.error("Error moving token:", e);
            }
        }
        
        // Ensure final position is saved when drag ends
        async function finalizeTokenPosition(id, x, y) {
            if (!currentUser) return;
            try {
                await setDoc(doc(TOKENS_COLLECTION, id), { x, y }, { merge: true });
            } catch (e) { console.error(e); }
        }

        async function deleteToken(id) {
            if (!currentUser) return;
            // Optimistic delete
            delete tokens[id];
            draw();
            
            try {
                await deleteDoc(doc(TOKENS_COLLECTION, id));
            } catch (e) {
                console.error("Error deleting token:", e);
            }
        }


        // --- Input Handling ---

        function getPointerPos(e) {
            if (e.touches && e.touches.length > 0) {
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
            return { x: e.clientX, y: e.clientY };
        }

        function findTokenAt(x, y) {
            const ids = Object.keys(tokens).reverse();
            for (let id of ids) {
                const t = tokens[id];
                const dx = x - t.x;
                const dy = y - t.y;
                if (dx*dx + dy*dy <= 25 * 25) return t;
            }
            return null;
        }

        function handleStart(x, y) {
            const clickedToken = findTokenAt(x, y);

            if (clickedToken) {
                dragData.item = clickedToken.id;
                dragData.offsetX = x - clickedToken.x;
                dragData.offsetY = y - clickedToken.y;
                draw(); // Redraw to show selection highlight
            } else {
                createToken(x, y);
            }
        }

        function handleMove(x, y) {
            if (dragData.item && tokens[dragData.item]) {
                const newX = x - dragData.offsetX;
                const newY = y - dragData.offsetY;
                
                // Update local state immediately for smooth 60fps
                tokens[dragData.item].x = newX;
                tokens[dragData.item].y = newY;
                draw();

                // Send network update (throttled)
                updateTokenPosition(dragData.item, newX, newY);
            }
        }

        function handleEnd() {
            if (dragData.item && tokens[dragData.item]) {
                // Send final authoritative position
                finalizeTokenPosition(dragData.item, tokens[dragData.item].x, tokens[dragData.item].y);
            }
            dragData.item = null;
            draw();
        }

        // Mouse Events
        canvas.addEventListener('mousedown', e => {
            if (e.button === 0) handleStart(e.clientX, e.clientY);
        });
        canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', handleEnd);

        // Right Click (Delete)
        canvas.addEventListener('contextmenu', e => {
            e.preventDefault();
            const token = findTokenAt(e.clientX, e.clientY);
            if (token) deleteToken(token.id);
        });

        // Touch Events
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const pos = getPointerPos(e);
            handleStart(pos.x, pos.y);
        }, { passive: false });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            const pos = getPointerPos(e);
            handleMove(pos.x, pos.y);
        }, { passive: false });

        canvas.addEventListener('touchend', handleEnd);

        // Start
        initGame();

    </script>
</body>
</html>
