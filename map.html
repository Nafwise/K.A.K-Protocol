<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Akashic Atlas | Game Mode</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020617; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); pointer-events: none; mix-blend-mode: difference;
        }
    </style>
</head>
<body>
    <div id="crosshair">
        <svg viewBox="0 0 100 100" fill="none" stroke="white" stroke-width="2">
            <circle cx="50" cy="50" r="40" stroke-opacity="0.5"/>
            <line x1="50" y1="30" x2="50" y2="70" />
            <line x1="30" y1="50" x2="70" y2="50" />
        </svg>
    </div>

    <script>
        // --- CONFIG & STATE ---
        const config = {
            chunkSize: 32,
            playerHeight: 1.8,
            moveSpeed: 10,
            gravity: 25,
            jumpForce: 10
        };

        const state = {
            isPaused: false,
            velocity: new THREE.Vector3(),
            direction: new THREE.Vector3(),
            canJump: false,
            raycastTarget: null
        };

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020617); // Deep Slate
        scene.fog = new THREE.Fog(0x020617, 10, 60);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // --- VOXEL WORLD GENERATION ---
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        
        // Material Palette (Akashic Theme)
        const materials = {
            floor: new THREE.MeshLambertMaterial({ color: 0x1e293b }), // Slate 800
            wall: new THREE.MeshLambertMaterial({ color: 0x334155 }),  // Slate 700
            combat: new THREE.MeshLambertMaterial({ color: 0xef4444, emissive: 0x450a0a }), // Red (Trigger)
            loot: new THREE.MeshLambertMaterial({ color: 0xf59e0b, emissive: 0x451a03 }),   // Gold (Trigger)
            lore: new THREE.MeshLambertMaterial({ color: 0x06b6d4, emissive: 0x083344 }),   // Cyan (Trigger)
        };

        const objects = []; // For collision
        const triggers = []; // For game logic

        function createBlock(x, y, z, type) {
            const mesh = new THREE.Mesh(geometry, materials[type]);
            mesh.position.set(x, y, z);
            mesh.userData = { type: type }; // Tag for logic
            scene.add(mesh);
            objects.push(mesh);
            if (['combat', 'loot', 'lore'].includes(type)) {
                triggers.push(mesh);
            }
        }

        // Generate "Level 1"
        function generateLevel() {
            // Floor
            for(let x = -20; x <= 20; x++) {
                for(let z = -20; z <= 20; z++) {
                    createBlock(x, 0, z, 'floor');
                    // Random Walls
                    if (Math.random() > 0.9) {
                        createBlock(x, 1, z, 'wall');
                        createBlock(x, 2, z, 'wall');
                    }
                }
            }

            // Points of Interest
            createBlock(0, 1, -5, 'loot'); // Chest nearby
            createBlock(5, 1, 5, 'combat'); // Enemy spawn
            createBlock(-5, 1, 5, 'lore'); // Lore terminal
            
            // Walls around edges
            for(let i = -20; i <= 20; i++) {
                createBlock(i, 1, -20, 'wall'); createBlock(i, 2, -20, 'wall');
                createBlock(i, 1, 20, 'wall'); createBlock(i, 2, 20, 'wall');
                createBlock(-20, 1, i, 'wall'); createBlock(-20, 2, i, 'wall');
                createBlock(20, 1, i, 'wall'); createBlock(20, 2, i, 'wall');
            }
        }

        generateLevel();

        // --- CONTROLS (PointerLock) ---
        // Simplified implementation to avoid external dependencies
        const controls = {
            isLocked: false,
            getObject: () => camera,
            lock: () => document.body.requestPointerLock(),
            unlock: () => document.exitPointerLock()
        };

        camera.position.set(0, 2, 0); // Start position
        const pitchObject = new THREE.Object3D();
        pitchObject.add(camera);
        const yawObject = new THREE.Object3D();
        yawObject.position.y = 2; // Eyes height
        yawObject.add(pitchObject);
        scene.add(yawObject);

        document.addEventListener('click', () => {
            if(!state.isPaused) controls.lock();
        });

        document.addEventListener('pointerlockchange', () => {
            controls.isLocked = document.pointerLockElement === document.body;
        });

        document.addEventListener('mousemove', (event) => {
            if (controls.isLocked && !state.isPaused) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                yawObject.rotation.y -= movementX * 0.002;
                pitchObject.rotation.x -= movementY * 0.002;
                pitchObject.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitchObject.rotation.x));
            }
        });

        // Keyboard Input
        const keyState = {};
        document.addEventListener('keydown', (e) => keyState[e.code] = true);
        document.addEventListener('keyup', (e) => keyState[e.code] = false);

        // Interaction (E)
        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyE' && state.raycastTarget) {
                const type = state.raycastTarget.object.userData.type;
                // Send Event to Parent
                window.parent.postMessage({ 
                    type: 'TRIGGER_EVENT', 
                    kind: type.toUpperCase() 
                }, '*');
                
                // Unlock mouse so user can use the UI
                controls.unlock();
            }
        });

        // --- GAME LOOP & PHYSICS ---
        const raycaster = new THREE.Raycaster();
        const prevTime = performance.now();
        let lastInteractionCheck = 0;

        function checkCollision(pos) {
            // Simple voxel collision: check if position is inside a block
            // In a real voxel engine, we check the grid. Here we check bounds.
            for(let obj of objects) {
                // very simple box check
                if (Math.abs(pos.x - obj.position.x) < 0.8 && 
                    Math.abs(pos.z - obj.position.z) < 0.8 &&
                    Math.abs(pos.y - obj.position.y) < 1) {
                    return true;
                }
            }
            return false;
        }

        function animate() {
            requestAnimationFrame(animate);

            if (state.isPaused) return;

            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            
            // Interaction Raycast
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(triggers);
            
            if (intersects.length > 0 && intersects[0].distance < 3) {
                if (state.raycastTarget !== intersects[0]) {
                    state.raycastTarget = intersects[0];
                    const type = intersects[0].object.userData.type;
                    window.parent.postMessage({ 
                        type: 'INTERACTION_AVAILABLE', 
                        available: true, 
                        label: type.toUpperCase() 
                    }, '*');
                }
            } else {
                if (state.raycastTarget) {
                    state.raycastTarget = null;
                    window.parent.postMessage({ type: 'INTERACTION_AVAILABLE', available: false }, '*');
                }
            }

            // Movement Logic
            if (controls.isLocked) {
                state.velocity.x -= state.velocity.x * 10.0 * delta;
                state.velocity.z -= state.velocity.z * 10.0 * delta;
                state.velocity.y -= 9.8 * 2.0 * delta; // Gravity

                state.direction.z = Number(keyState['KeyW'] || 0) - Number(keyState['KeyS'] || 0);
                state.direction.x = Number(keyState['KeyD'] || 0) - Number(keyState['KeyA'] || 0);
                state.direction.normalize();

                if (keyState['Space'] && state.canJump) {
                    state.velocity.y += config.jumpForce;
                    state.canJump = false;
                }

                if (keyState['KeyW'] || keyState['KeyS']) state.velocity.z -= state.direction.z * 400.0 * delta;
                if (keyState['KeyA'] || keyState['KeyD']) state.velocity.x -= state.direction.x * 400.0 * delta;

                // Apply movement
                yawObject.translateX(-state.velocity.x * delta);
                yawObject.translateZ(state.velocity.z * delta); // Inverted Z for Three.js
                yawObject.position.y += state.velocity.y * delta;

                // Floor Collision
                if (yawObject.position.y < config.playerHeight) {
                    state.velocity.y = 0;
                    yawObject.position.y = config.playerHeight;
                    state.canJump = true;
                }
            }

            renderer.render(scene, camera);
        }

        animate();

        // --- COMMUNICATION FROM SHELL ---
        window.addEventListener('message', (event) => {
            const data = event.data;
            if (data.type === 'PAUSE_GAME') {
                state.isPaused = true;
                controls.unlock();
            }
            if (data.type === 'RESUME_GAME') {
                state.isPaused = false;
                // Wait for click to relock
            }
        });

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>